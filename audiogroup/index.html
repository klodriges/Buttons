<!DOCTYPE html>
<html>
<head>
  <title>AudioGroup</title>

  <script src="https://mcorp.no/lib/mcorp-2.0.js"></script>
  <script text="javascript" src="https://webtiming.github.io/timingsrc/lib/timingsrc-v2.js"></script>

  <script>

    if (localStorage.vizid === undefined) {
      localStorage.vizid = (Math.random()*1000000000).toFixed(0);
      // Use this later!
    }

    var app = MCorp.app("8113568792798709392");
    app.to_s = new TIMINGSRC.TimingObject();
    app.to_beats = new TIMINGSRC.ScaleConverter(app.to_s, 120/60.);  // BPM
    app.ready
    .then(function() {
      let SERVER = "ws://localhost:4444";

      app.to_s.timingsrc = app.motions.playback;  // should be recording

      var Uploader = function(url, onError) {
        var API = {};
        var ws;
        var ts_sent = false;
        var resetting = false;
        var total_sent = 0;
        var recordedChunks = [];
        var metaChunks = [];
        var images = [];
        var statusTimeout;

        var connect = function() {
          if (ws) {
            //try {
              ws.close();
            //} catch (e) {
            //}
          }

          try {
            ws = new WebSocket(url);      
            ws.binaryType = 'arraybuffer';
            console.log("Opening websocket");
            ws.onopen = function(event) {
              // Trigger metadata sending?        
              console.log("WebSocket is open, ready to upload data");
              API.reset();
              document.querySelector("#status").innerHTML = "Idle";
              //set_record_btn_active(false);
              upload();
            };

            ws.onerror = function(event) {
              console.log("ERROR", event);
              ws.close();
              if (onError) {
                try {
                  onError();
                } catch (err) {
                  console.log("Error reporting error", err);
                }
              }
            };
            ws.onclose = function() {
              ws = undefined;
            };

          } catch (e) {
            console.log("Error connecting to server:", e);
            ws = undefined;
          }
        };

      var _send = function(data) {
        try {
          ws.send(data);
        } catch (err) {
          console.log("Error sending data");
          ws.onerror(err);
        }
      };
      var upload = function() {
        if (ws === undefined) {
          console.log("Upload requested, but not connected");
          connect();
          return;
        }
        var dv;
        if (metaChunks.length > 0) {
          console.log("Have metachunk");
          // Meta-package
          var data = metaChunks.shift();

          var pkg = new ArrayBuffer(50);
          dv = new DataView(pkg);
          dv.setUint16(0, 0xf4db);
          dv.setUint32(2, parseInt(localStorage.vizid));
          dv.setFloat64(6, data.ts);

          dv.setFloat64(14, data.position.coords.latitude);
          dv.setFloat64(22, data.position.coords.longitude);
          dv.setUint16(30, data.position.coords.altitude);
          dv.setUint16(32, data.position.coords.accuracy);

          dv.setFloat64(34, data.heading);  // heading (0 degrees is north, 180 is south)
          dv.setFloat64(42, data.pitch);  // pitch (0 degrees is flat, 180 is up)
          _send(pkg);
          setTimeout(upload, 0);
        }

        if (recordedChunks.length > 0) {
          if (!resetting && ts_sent === false) {
            console.log("Sending TS message");
            ts_sent = true;
            // First data block, send the timestamp first
            var package = new ArrayBuffer(14);
            dv = new DataView(package);
            dv.setUint16(0, 0xf4de);
            dv.setUint32(2, parseInt(localStorage.vizid));
            dv.setFloat64(6, recordedChunks[0][0]);
            _send(package); //new Blob([dv]));
          }
          var chunk = recordedChunks.shift();
          if (chunk[0] === undefined) {
            clearTimeout(statusTimeout);
            document.querySelector("#status").innerHTML = "Idle";
            // set_record_btn_active(false);

            // Message already prepared (is likely END), just send it
            ws.send(chunk[1]);
            resetting = false;
          } else {
            var filereader = new FileReader();
            filereader.onload = function() {
              total_sent += this.result.byteLength;
              document.querySelector("#sent").innerHTML = (total_sent / 1024).toFixed(0);
              ws.send(this.result);
              setTimeout(upload, 0);          
            };
            filereader.readAsArrayBuffer(chunk[1]);
          }
        }

        if (images.length > 0) {
          console.log("Will send image");
          var data = images.shift();
          var byteString = atob(data.image.split(',')[1]);
          var pkg = new ArrayBuffer(byteString.length + 14);
          dv = new DataView(pkg);
          dv.setUint16(0, 0xfbd);
          dv.setUint32(2, parseInt(localStorage.vizid));
          dv.setFloat64(6, data.ts);
          for (var j=0; j < byteString.length; j++) {
            dv.setInt8(j + 14, byteString.charCodeAt(j));
          }
          _send(pkg);
          console.log("Image sent");
        }
      };
      var sendMeta = function(data) {
        if (!ws) {
          console.log("Skipping metadata, no connection");
        }
      };

      API.pushData = function(ts, data) {
        if (data === undefined) {
          throw new Error("Need data to send");      
        }
        recordedChunks.push([ts, data]);
        var status = "Recording";
        if (recordedChunks.length > 4) {
          status = "NETWORK TOO SLOW";
        } else if (recordedChunks.length > 2) {
          status = "Network seems a bit slow";
        }
        clearTimeout(statusTimeout);
        document.querySelector("#status").innerHTML = status;
        //set_record_btn_active(true);
        statusTimeout = setTimeout(function() {
          document.querySelector("#status").innerHTML = "Unplanned stop";
          //set_record_btn_active(false);
        }, 1000);
        setTimeout(upload, 0);
      };

      API.pushMeta = function(ts, position, heading, pitch) {
        var meta = {
          ts: ts,
          position: position,
          heading: heading,
          pitch: pitch
        };
        metaChunks.push(meta);
        setTimeout(upload, 0);
      };

      API.pushImage = function(ts, image) {
        images.push({ts: ts, image: image});
        setTimeout(upload, 0);
      };

      // Should be called when a new recording is being made
      API.reset = function() {
        if (ts_sent === true) { // we've transmitted video, send end of video
          resetting = true;
          console.log("Sending END");
          var package = new ArrayBuffer(2);
          var dv = new DataView(package);
          dv.setUint16(0, 0xf4ff);
          setTimeout(function() {
            API.pushData(undefined, package);        
          }, 500); // Allow time for video shutdown to complete
        }
        ts_sent = false;
      }; 
      connect();

      return API;
      };

      navigator.mediaDevices.getUserMedia({audio: true})
      .then(function(stream) {
        app.calibrate = 0;
        let options = {
          mimeType: 'audio/ogg; codecs=opus'
        };
        var mediaRecorder = new MediaRecorder(stream);
        window.mr = mediaRecorder;
        console.log("Stream is", stream);
        app.uploader = Uploader(SERVER);
        let running = false;
        app.motions.record.on("change", function() {
          // If the record motion is running, we shold record!
          if (this.pos) {  // We currently trigger on record - let this be a button
            running = true;
            console.log("Recording!");
            mediaRecorder.start(100);
          } else {
            // Done
            if (running)
              mediaRecorder.stop();
          }
        });
        
        mediaRecorder.ondataavailable = function(e) {
          console.log("GOT DATA");
          if (!app.startTime) {
            // We request 100ms of data, so date it back
            // If we rather use app.motions.epoc.pos here we'll save all files
            app.startTime = app.to_s.pos - 100 - app.calibrate;
            // We shold share this url within the group
            let url = "http://example.com/full/" + parseInt(localStorage.vizid) + "_" + Math.floor(app.startTime);
            let profile = {
              key: parseInt(localStorage.vizid),
              name: "Some name",
              url: url,
              offset: app.to_s.pos
            }
            console.log("My profile is now:", profile);
            app.uploader.pushData(self.startTime - 0.100 - app.calibrate, e.data);
          } else {
            app.uploader.pushData(app.to_s.pos - 0.100 - app.calibrate, e.data);            
          }
        };
      });

      console.log("jabl");
      // Metronome
      let draw_metronome = function() {
        // Repetitions is beats mod beats pr cycle
        let beat_nr = Math.floor(app.to_s.pos * (app.motions.bpm.pos / 60.));
        document.querySelector("#rep").innerHTML = Math.floor(beat_nr / app.motions.bpc.pos);
        document.querySelector("#beat").innerHTML = Math.floor(beat_nr % app.motions.bpc.pos) + 1;
        //#rep
        requestAnimationFrame(draw_metronome);
      }
      requestAnimationFrame(draw_metronome);

      // We also need a skip function to start before based on bpm - the 
      // scale converter doesn't do dynamic changes
      app.skip_to_beat = function(beat, vel) {
        let pos = beat * app.motions.bpm.pos / 60.;
        app.to_s.update({velocity: vel, position: pos});
      }

      app.motions.bpm.on("change", function() {
        document.querySelector("#bpm").innerHTML = this.pos;
      });
      app.motions.bpc.on("change", function() {
        document.querySelector("#bpc").innerHTML = this.pos;
      });
    });



  </script>

</head>
<body>
<div id="status" class="status"></div>
<div id="sent" class="sent"></div>

<div class="metronome">

  <div id="rep"></div>
  <div id="beat"></div>
  <div><span id="bpm"></span>bpm</div>
  <div><span id="bpc"></span>/4</div>

</div>

</body>
</html>